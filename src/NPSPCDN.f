C
C
C
      SUBROUTINE NPSPCDN(Y,SY,L,U,F,RES,W,THRSH,KNX,KNV,KNSTR,N,
     +                            NKNTS,SQZFAC,NPEAK,KK,MULT,LCL,ALPHA)
      DOUBLE PRECISION Y(N),SY(N+1),L(N+1),U(N+1),F(N),RES(N),W(N+1)
      DOUBLE PRECISION THRSH(2*KK+2)
      INTEGER KNX(N+1),KNV(N+1),KNSTR(N+1)
      INTEGER KK,MULT,NPEAK,N
      DOUBLE PRECISION SQZFAC,ALPHA
C
      LOGICAL ADJUST
C
      CALL THRSHHLD(THRSH,KK,N,ALPHA,MULT)
C
      CALL INTGRTY(Y,SY,N)
      CALL SETBNDS(SY,L,U,N+1)
C
      IF(NPEAK.GT.0) GOTO 40
C
      IC=1
      IC=1
      ICO=0
      IF(MULT.EQ.0) THEN
         KKU1=0
         KKU2=KK+1
      ELSE
         KKU1=1
         KKU2=N
      ENDIF
C
      DO 30 IJ=KKU1,KKU2
C
 20	CONTINUE
	CALL STRING(L,U,N+1,KNX,KNV,KNSTR,NKNTS)
	CALL DSTRING(SY,L,U,N,KNSTR,NKNTS,F)
	CALL PEAKS0(F,N,KNSTR,NKNTS,NPEAK)
        CALL SCLDOBS(Y,F,N,RES)
c       write(*,*) IC,NPEAK,IJ
C
	ADJUST=.FALSE.
	CALL GGMLTRSTN(RES,KNV,N,W,THRSH,KK,MULT,ADJUST,IJ)
	IC=IC+1
C     
	IF (ADJUST) THEN
	   CALL ADJSTBDS(L,U,N,KNV,SQZFAC,LCL)
	   GOTO 20
	ENDIF
C
 30   CONTINUE
C
      IF(LCL.EQ.0) RETURN
C		
 40   CONTINUE
C
      CALL ADJSTBDS(L,U,N,KNV,SQZFAC,1)
      CALL STRING(L,U,N+1,KNX,KNV,KNSTR,NKNTS)
      CALL DSTRING(SY,L,U,N,KNSTR,NKNTS,RES)      
      CALL PEAKS0(RES,N,KNSTR,NKNTS,NPEAK0)
c      write(*,*) NPEAK,NPEAK0
      IF(NPEAK0.GT.NPEAK) RETURN
C
      DO 50 I=1,N
         F(I)=RES(I)
 50   CONTINUE
C
      GOTO 40

      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      SUBROUTINE INTGRTY(Y,SY,N)
      DOUBLE PRECISION Y(N),SY(N+1)
C
      SY(1)=0D0
      DO 10 I=2,N+1
         SY(I)=SY(I-1)+Y(I-1)/DBLE(N)
 10   CONTINUE
C
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      SUBROUTINE SETBNDS(SY,L,U,N)
      DOUBLE PRECISION SY(N),L(N),U(N)
C
      DOUBLE PRECISION DEV
C
      DEV=0D0
      DO 10 I=1,N
         DEV=DMAX1(DEV,DABS(SY(I)-SY(N)*DBLE(I)/DBLE(N)))
 10   CONTINUE
C
      DO 20 I=1,N
         L(I)=SY(I)-DEV
         U(I)=SY(I)+DEV
 20   CONTINUE
c      U(1)=0D0
c      L(1)=0D0
      U(1)=L(1)
      U(N)=SY(N)
      L(N)=SY(N)
C
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      SUBROUTINE STRING(L,U,N,KNX,KNV,KNSTR,NKNTS)
      DOUBLE PRECISION L(N),U(N)
      INTEGER KNX(N),KNV(N),KNSTR(N)
C
      DOUBLE PRECISION ST1,ST2
      LOGICAL FIXSTR
C
C
C                 ###INITIALIZE###
C
      ST1=L(1)
      KV=2
      KX=2
      KNX(1)=1
      KNX(2)=2
      KNV(1)=1
      KNV(2)=2
      NFIX=1
      NKNTS=1
      KNSTR(1)=1
C
      I=2
 10   CONTINUE
      I=I+1
      NN=N-NFIX+1
      IF (I.GT.N) GOTO 20
      II=I-NFIX+1
      ST2=L(NFIX)
      L(NFIX)=ST1
      CALL FTCNCV(L(NFIX),NN,KNV,KV,II)
      L(NFIX)=ST2
      ST2=U(NFIX)
      U(NFIX)=ST1
      CALL FTCNVX(U(NFIX),NN,KNX,KX,II)
      U(NFIX)=ST2
C
 20   CONTINUE
C
      CALL STRING0(L(NFIX),U(NFIX),NN,ST1,KNX,KNV,FIXSTR)
C
      IF(.NOT.FIXSTR) GOTO 10
C
      MNKN=MIN0(KNX(2),KNV(2))
      NFIX=NFIX+MNKN-1
      NN=NN-MNKN+1
      NKNTS=NKNTS+1
      IF(MNKN.EQ.KNX(2)) THEN
         KNSTR(NKNTS)=NFIX
         KNV(1)=1
         DO 30 IJ=2,KV
            KNV(IJ)=KNV(IJ)-MNKN+1
 30      CONTINUE
         KX=KX-1
         DO 40 IJ=1,KX
            KNX(IJ)=KNX(IJ+1)-MNKN+1
 40      CONTINUE
      ELSE
         KNSTR(NKNTS)=-NFIX
         KNX(1)=1
         DO 50 IJ=2,KX
            KNX(IJ)=KNX(IJ)-MNKN+1
 50      CONTINUE
         KV=KV-1
         DO 60 IJ=1,KV
            KNV(IJ)=KNV(IJ+1)-MNKN+1
 60      CONTINUE
      ENDIF
C
      IF(NFIX.EQ.N) RETURN
C
      GOTO 20
C
      END
C         
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C     THIS SUBROUTINE CALCULATES THE SMALLEST CONCAVE MAJORANT OF THE
C     LOWER BOUNDARY UNTIL A POINT IS REACHED WHERE THIS IS GREATER THAN 
C     THE UPPER BOUNDARY. THE POSITIONS OF THE KNOTS ARE STORED IN KN. 
C
      SUBROUTINE FTCNCV(F,N,KN,K,I)
      DOUBLE PRECISION F(N)
      INTEGER KN(N)
C
C
      IF(I.GT.N) RETURN
      KN1=KN(1)
      KN(1)=1
      IF (F(I)-F(KN(K)).LT.(F(KN(K))-F(KN(K-1)))/DBLE(KN(K)-KN(K-1)))
     +                                                             THEN
         K=K+1
         KN(K)=I
         KN(1)=KN1
         RETURN
      ENDIF
C
C                      ###BACKTRACK###
C
      JK=K-1
 20   CONTINUE
      IF(JK.EQ.1) GOTO 30
      IF ((F(I)-F(KN(JK)))/DBLE(I-KN(JK)).GE.(F(KN(JK))-F(KN(JK-1)))/
     +     DBLE(KN(JK)-KN(JK-1))) THEN
         JK=JK-1
         GOTO 20
      ENDIF
C
 30   CONTINUE
C
      K=JK+1
      KN(K)=I
      KN(1)=KN1
C
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC        
C     THIS SUBROUTINE CALCULATES THE LARGEST CONVEX MINORANT OF THE
C     UPPER BOUNDARY UNTIL A POINT IS REACHED WHERE THIS IS LESS THAN 
C     THE LOWER BOUNDARY. THE POSITIONS OF THE KNOTS ARE STORED IN KN.
C 
      SUBROUTINE FTCNVX(F,N,KN,K,I)
      DOUBLE PRECISION F(N)
      INTEGER KN(N)
C
C
      IF(I.GT.N) RETURN
      KN1=KN(1)
      KN(1)=1
C
      IF (F(I)-F(KN(K)).GT.(F(KN(K))-F(KN(K-1)))/DBLE(KN(K)-KN(K-1)))
     +                                                             THEN
         K=K+1
         KN(K)=I
         KN(1)=KN1
         RETURN
      ENDIF
C
C                      ###BACKTRACK###
C
      JK=K-1
 20   CONTINUE
      IF(JK.EQ.1) GOTO 30
      IF ((F(I)-F(KN(JK)))/DBLE(I-KN(JK)).LE.(F(KN(JK))-F(KN(JK-1)))/
     +     DBLE(KN(JK)-KN(JK-1))) THEN
         JK=JK-1
         GOTO 20
      ENDIF
C
 30   CONTINUE
C
      K=JK+1
      KN(K)=I
      KN(1)=KN1
C     
      END
C         
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
      SUBROUTINE STRING0(L,U,N,STR1,KNX,KNV,FIXSTR)
      DOUBLE PRECISION L(N),U(N)
      INTEGER KNX(N),KNV(N)
      DOUBLE PRECISION GRX1,GRV0,STR1
      LOGICAL FIXSTR
C
      FIXSTR=.FALSE.
C
C        ###CHECK IF INITIAL GRADIENTS CONSISTEN###
C
      GRX1=(U(KNX(2))-STR1)/DBLE(KNX(2)-1)
      GRV0=(L(KNV(2))-STR1)/DBLE(KNV(2)-1)
C
C                   ###IF YES RETURN###
C
      IF (GRX1.GT.GRV0) RETURN
C
C                   ###IF NOT, FIX STRING###
C
      IF(KNX(2).LE.KNV(2)) THEN
         STR1=U(KNX(2))
      ELSE
         STR1=L(KNV(2))
      ENDIF
C
      FIXSTR=.TRUE.
C
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C     COUNTS ONLY INTERIOR PEAKS
C
      SUBROUTINE PEAKS0(D,N,KN,NKN,NPEAK)
      DOUBLE PRECISION D(N)
      INTEGER KN(NKN)
C
C
      NPEAK=0
      IF(NKN.LE.3) RETURN
      DO 10 I=2,NKN-1
         J1=IABS(KN(I-1))-1
         J2=IABS(KN(I))-1
         J3=IABS(KN(I+1))-1
         IF(D(J1).LT.D(J2).AND.D(J2).GT.D(J3)) NPEAK=NPEAK+1
 10   CONTINUE
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
      SUBROUTINE DSTRING(SY,L,U,N,KNTS,NKNTS,F)
      DOUBLE PRECISION SY(N+1),L(N+1),U(N+1),F(N)
      INTEGER KNTS(NKNTS)
C
      DOUBLE PRECISION B0,B1,D
C
C
C
c      IF(KNTS(2).GT.0) THEN
c         D=DBLE(N)*(U(IABS(KNTS(2)))-U(1))/DBLE(IABS(KNTS(2))-1)
c      ELSE
c         D=DBLE(N)*(L(IABS(KNTS(2)))-U(1))/DBLE(IABS(KNTS(2))-1)
c      ENDIF
      D=DBLE(N)*SY(IABS(KNTS(2)))/DBLE(IABS(KNTS(2))-2)
C
      F(1)=0D0
      DO 10 I=2,IABS(KNTS(2))-1
         F(I)=D
 10   CONTINUE
C
      IK=2
 20   CONTINUE
      IK=IK+1
      IF(IK.GT.NKNTS) RETURN
      KIK=IABS(KNTS(IK))
      KIK1=IABS(KNTS(IK-1))
      IF (KNTS(IK-1).GT.0.AND.KNTS(IK).GT.0) THEN
         B0=U(KIK1)
         B1=U(KIK)
      ELSEIF(KNTS(IK-1).LT.0.AND.KNTS(IK).LT.0) THEN
         B0=L(KIK1)
         B1=L(KIK)
      ELSE
         B0=SY(KIK1)
         B1=SY(KIK)
      ENDIF
      D=DBLE(N)*(B1-B0)/DBLE(KIK-KIK1)
      DO 30 I=KIK1,KIK-1
         F(I)=D
 30   CONTINUE
      GOTO 20
C
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
      SUBROUTINE SCLDOBS(Y,F,N,RES)
      DOUBLE PRECISION Y(N),F(N),RES(N)
C
      DO 10 I=1,N
         RES(I)=Y(I)/F(I)
 10   CONTINUE
      RES(1)=1D0
C
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      SUBROUTINE GGMLTRSTN(RES,KNV,N,W,THRSH,KK,MULT,ADJUST,KIJ)
      DOUBLE PRECISION RES(N),W(N+1),THRSH(2*KK+2)
      INTEGER KNV(N)
      INTEGER MULT
      LOGICAL ADJUST
C
      DOUBLE PRECISION D
C
C
      ADJUST=.FALSE.
      W(1)=0D0
      DO 10 I=2,N+1
         KNV(I-1)=0
         W(I)=W(I-1)+RES(I-1)
 10   CONTINUE
C
      IF(MULT.EQ.0) GOTO 60
C
C
      IF(KIJ.LT.N) THEN
         IKIJ=N-KIJ
      ELSE
         IKIJ=N-1
      ENDIF
      DO 50 I=1,IKIJ
         IF(KIJ.LT.N) THEN
            JKIJ1=I+KIJ-1
            JKIJ2=I+KIJ-1
         ELSE
            JKIJ1=I
            JKIJ2=N
         ENDIF
         DO 40 J=JKIJ1,JKIJ2
            M=J-I+1
            D=W(J+1)-W(I)
            IF(D.LT.THRSH(M).OR.D.GT.THRSH(N+M)) THEN
               DO 30 K=I,J
                  KNV(K)=1
 30            CONTINUE
               ADJUST=.TRUE.
            ENDIF
 40      CONTINUE
 50   CONTINUE
C
      RETURN
C      
 60   CONTINUE
C
      IF(KIJ.LE.KK) THEN
         KK1=KIJ
         KK2=KIJ
      ELSE
         KK1=0
         KK2=KK
      ENDIF
C
      DO 90 K=KK1,KK2
         K2=2**K
         NK=N/K2
         IF(K2*NK.LT.N) NK=NK+1
         DO 80 KN=1,NK
            I=(KN-1)*K2+1
            IF (KN*K2.LE.N) THEN
               J=KN*K2
               D=W(J+1)-W(I)
            ELSE
               J=N
               D=DBLE(K2)*(W(N+1)-W(I))/DBLE(J-I+1)
            ENDIF
            IF(D.LT.THRSH(K+1).OR.D.GT.THRSH(KK+K+2)) THEN
               DO 70 IJ=I,J
                  KNV(IJ)=1
 70            CONTINUE
               ADJUST=.TRUE.
            ENDIF
 80      CONTINUE
 90   CONTINUE
C
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      SUBROUTINE ADJSTBDS(L,U,N,KNV,SQZFAC,LCL)
      DOUBLE PRECISION L(N+1),U(N+1)
      INTEGER KNV(N)
      DOUBLE PRECISION SQZFAC
C
      DOUBLE PRECISION D
C
      IF(LCL.NE.0) GOTO 30
      DO 20 J=1,N
         IF(KNV(J).EQ.1) THEN
            D=(U(J+1)-L(J+1))/2D0
            IF(D.GT.1D-10) THEN
               U(J+1)=U(J+1)-(1D0-SQZFAC)*D
               L(J+1)=L(J+1)+(1D0-SQZFAC)*D
            ENDIF
            IF(J.GE.2.AND.KNV(J-1).EQ.0) THEN
               D=(U(J)-L(J))/2D0
               IF(D.GT.1D-10) THEN
                  U(J)=U(J)-(1D0-SQZFAC)*D
                  L(J)=L(J)+(1D0-SQZFAC)*D
               ENDIF
            ENDIF
         ENDIF
 20   CONTINUE
      RETURN
C
 30   CONTINUE
C
      DO 40 J=1,N+1
         D=(U(J)-L(J))/2D0
         U(J)=U(J)-(1D0-SQZFAC)*D
         L(J)=L(J)+(1D0-SQZFAC)*D
 40   CONTINUE

      END
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      SUBROUTINE THRSHHLD(THRSH,KK,N,ALPHA,MULT)
      DOUBLE PRECISION THRSH(2*KK+2)
      DOUBLE PRECISION ALPHA
C
      DOUBLE PRECISION BETA1,BETA2
      DOUBLE PRECISION QUGAMMA
C
C
      BETA2=1D0-(1D0-ALPHA)/DBLE(2*N)
      BETA1=1D0-BETA2
C
C
      IF(MULT.GT.0) THEN
         DO 10 I=1,KK+1
            THRSH(I)=QUGAMMA(BETA1,DBLE(I))
            THRSH(KK+I+1)=QUGAMMA(BETA2,DBLE(I))
 10      CONTINUE
      ELSE
         DO 20 I=0,KK
            THRSH(I+1)=QUGAMMA(BETA1,DBLE(2**I))
            THRSH(KK+2+I)=QUGAMMA(BETA2,DBLE(2**I))
 20      CONTINUE
      ENDIF
C
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      DOUBLE PRECISION	FUNCTION PRGAU(X)
      DOUBLE PRECISION X
      DOUBLE PRECISION B(5),RT2PI,P,S,T,Y

      DATA B/.31938153D0,-.356563782D0,1.781477937D0,-1.821255978D0,
     *	     1.330274429D0/,RT2PI/2.506628275D0/,P/.2316419D0/

      Y=DABS(X)
      IF(Y.GT.6D0) THEN
	   PRGAU=1D0
      ELSE
	   T=(1D0+P*Y)**(-1)
           S=B(1)*T+B(2)*T**2+B(3)*T**3+B(4)*T**4+B(5)*T**5
	   PRGAU=1D0-DEXP(-0.5D0*Y**2)*S/RT2PI
      ENDIF
      IF(X.GE.0D0) RETURN
      PRGAU=1D0-PRGAU
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      DOUBLE PRECISION FUNCTION PRGAMMA(X,AK)
      DOUBLE PRECISION X,AK
C
      DOUBLE PRECISION A,AAK,Y
      DOUBLE PRECISION FTGAMMA,KH0,PRGAU,SUM
C
      IF(AK.GE.3D1.OR.DABS(X-AK).GE.2D0*DSQRT(AK)) THEN
         Y=X/AK
         PRGAMMA=PRGAU(DSQRT(2D0)*KH0(Y,AK))
      ELSE
         J=1
 10      CONTINUE
         IF(AK+DBLE(J).LT.3D1) THEN
            J=J+1
            GOTO 10
         ENDIF
         AAK=AK+DBLE(J)
c         write(*,*) J
         SUM=1D0
         A=1D0
         DO 20 I=1,J-1
            A=A*X/(AK+DBLE(I))
            SUM=SUM+A
 20      CONTINUE
         SUM=SUM*DEXP(AK*DLOG(X)-X)/FTGAMMA(AK+1D0)
         Y=X/AAK
         PRGAMMA=SUM+PRGAU(DSQRT(2D0)*KH0(Y,AAK))
      ENDIF
C      
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
      DOUBLE PRECISION FUNCTION KH0(X,AK)
      DOUBLE PRECISION X,AK
C
      DOUBLE PRECISION XMN,Y
C
C
      IF(DABS(X-1D0).GT.1D-3) THEN
         KH0=(X-1D0)**2/(X-1D0-DLOG(X))
         KH0=0.5D0*DLOG(KH0/2D0)
      ELSE
         KH0=0.0D0
      ENDIF
C
      KH0=KH0+AK*(X-1D0-DLOG(X))
      CALL KH0MIN(AK,XMN,Y)
      KH0=DSQRT(DMAX1(0D0,KH0-Y))
      IF(X.LT.XMN) KH0=-KH0
C      
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
      DOUBLE PRECISION FUNCTION KH01(X,AK)
      DOUBLE PRECISION X,AK
C
C
C
      IF(DABS(X-1D0).GT.1D-3) THEN
         KH01=2D0*X*(X-1D0-DLOG(X))-(X-1D0)**2
         KH01=KH01/(2D0*(X-1D0)*(X-1D0-DLOG(X)))
      ELSE
         KH01=(1D0-2D0*(X-1D0))/(3D0*X*(1D0-2D0*(X-1D0)/3D0))
      ENDIF
C
      KH01=KH01+AK*(X-1D0)/X
C
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      SUBROUTINE KH0MIN(AK,XMIN,Y)
      DOUBLE PRECISION AK,XMIN,Y
C
      DOUBLE PRECISION X0,X1,X2
      DOUBLE PRECISION KH01
C
C
      X1=1D0
      X0=1D0
 10   CONTINUE
      X0=X0/2D0
      Y=KH01(X0,AK)
      IF(Y.GT.0D0) GOTO 10
C
 20   CONTINUE
      X2=(X0+X1)/2D0
      IF(X1-X0.LT.1D-8) THEN
         XMIN=(X0+X1)/2D0
         GOTO 30
      ENDIF
      Y=KH01(X2,AK)
      IF(Y.GT.0D0) THEN
         X1=X2
      ELSE
         X0=X2
      ENDIF
      GOTO 20
C
 30   CONTINUE
C
      IF(DABS(XMIN-1D0).GT.1D-8) THEN
         Y=(XMIN-1D0)**2/(XMIN-1D0-DLOG(XMIN))
         Y=0.5D0*DLOG(Y/2D0)
      ENDIF
C
      Y=Y+AK*(XMIN-1D0-DLOG(XMIN))
C
      END
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      DOUBLE PRECISION FUNCTION QUGAMMA(P,K)
      DOUBLE PRECISION P,K
C
      DOUBLE PRECISION X0,X1,X2,Y
      DOUBLE PRECISION PRGAMMA
C
C
      X0=K
      Y=PRGAMMA(X0,K)
      IF(Y.LT.P) THEN
         X1=X0
 10      CONTINUE
         X1=2D0*X1
         Y=PRGAMMA(X1,K)
         IF(Y.LE.P) GOTO 10
      ELSE
         X1=X0
 20      CONTINUE
         X0=X0/2D0
         Y=PRGAMMA(X0,K)
         IF(Y.GE.P) GOTO 20
      ENDIF
C
 30   CONTINUE
      X2=(X1+X0)/2D0
      Y=PRGAMMA(X2,K)
      IF(DMAX1(DABS(Y/P-1D0),DABS((1D0-Y)/(1D0-P)-1D0)).LE.1D-5) THEN
         QUGAMMA=X2
         RETURN
      ENDIf
      IF(Y.GE.P) THEN
         X1=X2
      ELSE
         X0=X2
      ENDIF
      GOTO 30
C
      END

      
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C
C
      DOUBLE PRECISION FUNCTION FTGAMMA(K)
      DOUBLE PRECISION K
C
      DOUBLE PRECISION A,R2PI
C
      R2PI= 2.50662827463D0
C
C
      IF(K.GE.5D0) THEN
         A=K-1D0
         FTGAMMA=R2PI*DSQRT(A)*DEXP(A*DLOG(A)-A+1D0/(12D0*A)
     +        -1D0/(360D0*A**3))
      ELSEIF(K.GE.4D0) THEN
         FTGAMMA=R2PI*DSQRT(K)*DEXP(K*DLOG(K)-K+1D0/(12D0*K)
     +        -1D0/(360D0*K**3))
         FTGAMMA=FTGAMMA/K
      ELSEIF(K.GE.3D0) THEN
         A=K+1D0
         FTGAMMA=R2PI*DSQRT(A)*DEXP(A*DLOG(A)-A+1D0/(12D0*A)
     +        -1D0/(360D0*A**3))
         FTGAMMA=FTGAMMA/(K*(K+1D0))
      ELSEIF(K.GE.2D0) THEN
         A=K+2D0
         FTGAMMA=R2PI*DSQRT(A)*DEXP(A*DLOG(A)-A+1D0/(12D0*A)
     +        -1D0/(360D0*A**3))
         FTGAMMA=FTGAMMA/(K*(K+1D0)*(K+2D0))
      ELSEIF(K.GE.1D0) THEN
         A=K+3D0
         FTGAMMA=R2PI*DSQRT(A)*DEXP(A*DLOG(A)-A+1D0/(12D0*A)
     +        -1D0/(360D0*A**3))
         FTGAMMA=FTGAMMA/(K*(K+1D0)*(K+2D0)*(K+3D0))
      ELSE
         A=K+4D0
         FTGAMMA=R2PI*DSQRT(A)*DEXP(A*DLOG(A)-A+1D0/(12D0*A)
     +        -1D0/(360D0*A**3))
         FTGAMMA=FTGAMMA/(K*(K+1D0)*(K+2D0)*(K+3D0)*(K+4D0))
      ENDIF
C
      END
